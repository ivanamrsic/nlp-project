//
//  ProfilePresenter.swift
//  SentimentClassifier
//
//  Created by Ivana Mr≈°iƒá on 26.12.2020..
//  Copyright (c) 2020 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the üêç VIPER generator
//

import UIKit
import RxSwift
import RxCocoa

final class ProfilePresenter {

    // MARK: - Private properties

    private unowned let view: ProfileViewInterface
    private let interactor: ProfileInteractorInterface
    private let wireframe: ProfileWireframeInterface

    private let filtersRelay = BehaviorRelay<[String]>(value: ClassifierManager.shared.allResults)

    private let disposeBag = DisposeBag()

    // MARK: - Lifecycle

    init(view: ProfileViewInterface, interactor: ProfileInteractorInterface, wireframe: ProfileWireframeInterface) {
        self.view = view
        self.interactor = interactor
        self.wireframe = wireframe
    }
}

// MARK: - ProfilePresenterInterface

extension ProfilePresenter: ProfilePresenterInterface {

    func configure(with output: Profile.ViewOutput) -> Profile.ViewInput {
        handle(filterReviews: output.filterReviewsAction)
        handle(choosePhoto: output.choosePhotoAction)

        let delete = handle(deleteAll: output.deleteReviewsAction)
        let refresh = handle(createReview: output.createReviewAction)
        let items = createItems(with: Signal.merge(refresh, output.viewWillAppear, delete))

        return Profile.ViewInput(
            username: interactor.username,
            email: interactor.email,
            items: items,
            image: interactor.profilePhoto,
            reviewCount: items.map { $0.count }
        )
    }
}

// MARK: - Binding Setup

private extension ProfilePresenter {

    func handle(choosePhoto: Signal<Void>) {
        choosePhoto.emit(onNext: { [unowned wireframe] in
                wireframe.openChoosePhoto()
            })
            .disposed(by: disposeBag)
    }

    func handle(createReview: Signal<Void>) -> Signal<Void> {
        return createReview.flatMap { [unowned wireframe] in wireframe.openCreateReview() }
    }

    func handle(filterReviews: Signal<Void>) {
        filterReviews.emit(onNext: { [unowned self, unowned wireframe] in
                wireframe.openFilterReviews(with: self)
            })
            .disposed(by: disposeBag)
    }

    func handle(deleteAll: Signal<Void>) -> Signal<Void> {

        let alert = wireframe.deleteAlert(
            with: Strings.deleteReviews,
            message: Strings.deleteReviewsInfo,
            okMessage: Strings.ok,
            cancelMessage: Strings.cancel
        )

        let deleteAction = interactor.deleteAllReviews()

        return deleteAll
            .flatMap { alert.asDriver(onErrorDriveWith: .empty()) }
            .filter { $0 == .default }
            .map { _ in () }
            .flatMap { deleteAction.asSignal(onErrorSignalWith: .empty()) }
    }
}

// MARK: - Item creation

private extension ProfilePresenter {

    func createItems(with refresh: Signal<Void>) -> Driver<[TableCellItem]> {

        let reviews = refresh
            .do(onNext: { [unowned filtersRelay] in
                filtersRelay.accept(ClassifierManager.shared.allResults)
            })
            .flatMap { [unowned interactor] in
            interactor.fetchReviews().asDriver(onErrorDriveWith: .empty())
        }
        .asDriver(onErrorDriveWith: .empty())

        let itemDeleted = BehaviorRelay<Void>(value: ())

        return Driver
            .combineLatest(
                reviews,
                filtersRelay.asDriver(),
                itemDeleted.asDriver(onErrorDriveWith: .empty()))
            .map { [unowned self] (reviews, filters, _) in
                self.filter(reviews: reviews, filters: filters)
            }
            .map { [unowned self] in self.mapToItems(reviews: $0, itemDeleted: itemDeleted) }
    }

    func filter(reviews: [Review], filters: [String]) -> [Review] {
        return reviews.filter { review -> Bool in
            filters.contains(where: { $0 == review.sentiment })
        }
    }

    func mapToItems(reviews: [Review], itemDeleted: BehaviorRelay<Void>) -> [ReviewTableCellItem] {
        return reviews.map { [unowned interactor] review in
            let didDelete: () -> Void = { [unowned interactor] in
                interactor.delete(review: review)
                itemDeleted.accept(())
            }
            return ReviewTableCellItem(review: review, didDelete: didDelete)
        }
    }
}

// MARK: - FilterDelegate

extension ProfilePresenter: FilterDelegate {

    var currentFilters: [String] {
        return filtersRelay.value
    }

    func process(sentimentFilters: [String]) {
        filtersRelay.accept(sentimentFilters)
    }
}
